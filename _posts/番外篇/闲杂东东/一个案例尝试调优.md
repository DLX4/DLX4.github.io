首先，我们学习回顾下《深入理解java虚拟机》里面的介绍的调优案例。

------



案例1：一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个 CPU、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时 没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的网站使用。管理员为 了尽量利用硬件资源选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。 使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间失去响应的情况。 

> 分析：
>
> 64位虚拟机只支持server模式，此时默认使用的是吞吐量优先收集器。目测12GB的堆full GC停顿时间高达14秒。
>
> 文档序列化产生大对象直接进老年代，导致12GB的堆也很快耗尽。
>
> 控制full GC的关键是看应用中的大多数对象能否符合“朝生夕灭”，保障老年代稳定。然而这个案例场景不太好控制。
>
> 解决办法：
>
> 使用若干个32位虚拟机建立逻辑集群来利用硬件资源。 
>
> 改为CMS收集器进行垃圾回收（虽然吃CPU但是响应速度提上来了）。

------

案例2：不定时抛个异常

[org.eclipse.jetty.util.log]handle failed java.lang.OutOfMemoryError：null at sun.misc.Unsafe.allocateMemory（Native Method） at java.nio.DirectByteBuffer.＜init＞（DirectByteBuffer.java：99） at java.nio.ByteBuffer.allocateDirect（ByteBuffer.java：288） at org.eclipse.jetty.io.nio.DirectNIOBuffer.＜init＞ ……

> 分析：
>
> 大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位 Windows平台的限制是2GB。其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB 的堆之内，因此它最大也只能在剩余的0.4GB空间中分出一部分。
>
> 垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能 像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满 了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。
>
> 否则它只能一直等到抛出内存溢出 异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc（）！”。要是虚拟机还是不听 （譬如打开了-XX：+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内 存，自己却不得不抛出内存溢出异常了。
>
> 解决办法：
>
> Direct Memory：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出 OutOfMemoryError或者OutOfMemoryError：Direct buffer memory。 





