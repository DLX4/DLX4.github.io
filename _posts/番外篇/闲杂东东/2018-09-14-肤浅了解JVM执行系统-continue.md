大家知道写好java程序后，java程序经过javac编译器生成字节码（*.class），java虚拟机通过类加载机制加载字节码，在内存中形成可以直接使用的java类型，接下来再由字节码执行引擎去执行。

本文按照这个思路捋一下。

先说javac编译器生成字节码。

## class文件

Java虚拟机规范中定义了class文件结构。

- 魔数与Class文件的版本
- 常量池 
- 访问标志：这个Class是类还是接口；是否定义为public类 型；是否定义为abstract类型；如果是类的话，是否声明为final等
- 类索引、父类索引与接口索引（类实现了哪些接口）集合 
- 字段表集合 ：用于描述接口或者类中声明的变量。字段（field）包括类级变量以 及实例级变量。字段表集合中不会列出从超类或者父接口中继承而来的字段
- 方法表集合 ：表达了方法的定义，不含代码。
- 属性表集合 ：很杂，一堆属性：字节码指令，final常量值，方法的异常，源码行号和字节码的对应关系，局部变量描述，源文件名称等。。。

class文件中的东西多如牛毛，除了code属性里面的字节码，其它的都可以认为是元数据。所以接下来我们看下字节码是啥东东。

## 字节码

JVM具有语言无关性，换句话说，Java只是一张皮，Java语言中的各种变量、关键字和预算符号的语义都可以由字节码指令组合表达。

### 字节码指令集的特点：

- Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作 码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构 成。

- 由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。

- 限制了Java虚 拟机操作码的长度为一个字节（即0～255），操作码总数不可能超过256 条

  > 用一个字节来代 表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效 率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至 今。 

### 字节码指令有哪些

- 加载和存储指令：加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈 之间来回传输。

- 运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操 作栈顶。

- 类型转换指令 ：类型转换指令可以将两种不同的数值类型进行相互转换。

- 对象创建与访问指令 ：但Java虚拟机对类实例和数组的创建与操作使用了不同的 字节码指令。

  创建类实例的指令：new；创建数组的指令：newarray、anewarray、multianewarray；访问类字段和实例字段。。。

- 操作数栈管理指令 。用于直接操作操作数 栈的指令。

- 控制转移指令 。控制转移指令就是在有条件或 无条件地修改PC寄存器的值。

- 方法调用和返回指令 。

- 异常处理指令 。在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语 句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指 令检测到异常状况时自动抛出

- 同步指令 。

## 虚拟机类加载机制 

上面说了Class文件和里面的字节码，怎么把他们跑起来呢？

> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始 化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 

类加载机制的好处：

与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和 初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开 销，但是会为Java应用程序提供高度的**灵活性**。比如：

- 编写一个面向接口的应用程序， 可以等到运行时再指定其实际的实现类。
- 用户可以通过Java预定义的和自定义类加载器，让 一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部 分，这种组装应用程序的方式目前已广泛应用于Java程序之中。Applet、JSP、OSGi技术。

### 类加载的过程 

- 加载 ：从ZIP包中读取；从网络中获取；运行时计算生成（动态代理）；JSP文件生成。。

- 验证 ：Class文件并不 一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编 写来产生Class文件。。所以需要文件格式验证、 元数据验证、字节码验证、符号引用验证（对类自身以外的信息进行匹配验证）。

- 准备： 为类变量分配内存并设置类变量初始值。

- 解析 ：虚拟机将常量池内的符号引用替换为直接引用的过程。

  符号引用：在Class文件中它以CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。直接引用可以是直接指向目标的指针、相对偏移量或是 一个能间接定位到目标的句柄。

- 初始化 ：到了初始化 阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。 

  ＜clinit＞（）方法：由编译器自动收集类中的所有类变量的赋值动作和静态语句块 （static{}块）中的语句合并产生的。

  类的构造函数。

### 双亲委派

双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载）。

双亲委派在java.lang.ClassLoader中的loadClass方法中实现。

逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。

听说Tomcat打破了这个双亲委派机制？Tomcat为何这么吊！？

我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： 
1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 
2. 部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。 
3. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 
4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。

CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载`/common/*`、`/server/*`、`/shared/*`（在tomcat 6之后已经合并到根目录下的lib目录下）和`/WebApp/WEB-INF/*`中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，**每一个Web应用程序**对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。

tomcat 为了实现隔离性，没有遵守这个约定，每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。（**TODO：翻下源码确认下**）

## 虚拟机字节码执行引擎 





参考资料：

《深入理解Java虚拟机》

https://blog.csdn.net/qq_38182963/article/details/78660779