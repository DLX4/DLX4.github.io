首先，我们学习回顾下《深入理解java虚拟机》里面的介绍的调优案例。

------



案例1：一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个 CPU、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时 没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的网站使用。管理员为 了尽量利用硬件资源选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。 使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间失去响应的情况。 

> 分析：
>
> 64位虚拟机只支持server模式，此时默认使用的是吞吐量优先收集器。目测12GB的堆full GC停顿时间高达14秒。
>
> 文档序列化产生大对象直接进老年代，导致12GB的堆也很快耗尽。
>
> 控制full GC的关键是看应用中的大多数对象能否符合“朝生夕灭”，保障老年代稳定。然而这个案例场景不太好控制。
>
> 解决办法：
>
> 使用若干个32位虚拟机建立逻辑集群来利用硬件资源。 
>
> 改为CMS收集器进行垃圾回收（虽然吃CPU但是响应速度提上来了）。

------

案例2：不定时抛个异常

[org.eclipse.jetty.util.log]handle failed java.lang.OutOfMemoryError：null at sun.misc.Unsafe.allocateMemory（Native Method） at java.nio.DirectByteBuffer.＜init＞（DirectByteBuffer.java：99） at java.nio.ByteBuffer.allocateDirect（ByteBuffer.java：288） at org.eclipse.jetty.io.nio.DirectNIOBuffer.＜init＞ ……

> 分析：
>
> 大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位 Windows平台的限制是2GB。其中划了1.6GB给Java堆，而Direct Memory内存并不算入1.6GB 的堆之内，因此它最大也只能在剩余的0.4GB空间中分出一部分。
>
> 垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能 像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满 了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。
>
> 否则它只能一直等到抛出内存溢出 异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc（）！”。要是虚拟机还是不听 （譬如打开了-XX：+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内 存，自己却不得不抛出内存溢出异常了。
>
> 解决办法：
>
> Direct Memory：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出 OutOfMemoryError或者OutOfMemoryError：Direct buffer memory。 
>
>

个人觉得，JVM调优更像是debug，一点一点改善，有时候再怎么调还是治标不治本，比如编程原因根本上触发了bug。调优逻辑上分为：收集信息--发现问题--问题定位--改善问题。有时候还需要多轮改善，比如《深入理解java虚拟机》-5.3　实战：Eclipse运行速度调优 这个案例的调优过程比较有趣。

## Eclipse运行速度调优逻辑

### 第一部分：优化eclipse启动

1. 收集eclipse启动时的数据。包括：垃圾收集耗时，GC次数和耗时，类加载耗时，JIT编译耗时。。

2. 升级虚拟机版本。“免费的”性能提升岂不是美滋滋

3. 升级之后引入了新bug，解决bug。

   > 版本升级也有不少性能倒退的案例，受程序、第三方包兼容性以及中间件限制，在企业应 用中升级JDK版本是一件需要慎重考虑的事情。 

4. 收集新版本虚拟机运行数据。对比发现编译时间变长了，分析原因：

   > 为了解决程序解释执行的速度问题，JDK 1.2以后，虚拟机 内置了两个运行时编译器[3]，如果一段Java方法被调用次数达到一定程度，就会被判定为热 代码交给JIT编译器即时编译为本地代码，提高运行速度（这就是HotSpot虚拟机名字的由 来）。甚至有可能在运行期动态编译比C/C++的编译期静态译编出来的代码更优秀，因为运 行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条 件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题（主要是泄漏问题，如内 存泄漏、连接泄漏），随着代码被编译得越来越彻底，运行速度应当是越运行越快的。Java 的运行期编译最大的缺点就是它进行编译需要消耗程序正常的运行时间，这也就是上面所说 的“编译时间”。 

5. 试图减少编译时间：参数-Xint禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。----不可行，阉割了JIT之后JVM比乌龟还慢。一夜回到java 1.2前。

6. 优化GC。频繁GC会导致很多没有必要的安全点检测、线程挂起及恢复操作。

7. 分析GC日志，获取GC的原因，发现主要是老年代扩容导致的。优化设置新生代、java堆、永久代的容量，避免运行时自动扩展。

8. 优化设置之后再看下GC的日志，发现还有几次full GC，使用jstat-gccause查询一下最近一次GC的原因是system.gc()显式触发的。加入参数-XX： +DisableExplicitGC屏蔽掉System.gc（）。


### 第二部分：优化eclipse代码编译

1. 收集eclipse代码编译时的数据。发现CPU资源富余。
2. 通过并发利用CPU资源。替换掉Client模式的虚拟机中默认的新生代、老年代串行收集器。使用CMS收集器（ParNew收集器是使用CMS收集器后的默认新生代收集器）



*参考资料：《深入理解java虚拟机》*

