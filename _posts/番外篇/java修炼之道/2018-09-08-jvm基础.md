---
layout: post
title:  "JVM基础-内存管理"
date:   2018-09-08 15:14:54
categories: java修炼之道

---

# JVM基础-内存管理

## 运行时数据区域

根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域：

- 程序计数器 

  > 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指 令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）
  >
  > 此内存区域 是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

- Java虚拟机栈 

  > 每个方法在执行的同时 都会创建一个栈帧（Stack Frame[1]）用于存储局部变量表、操作数栈、动态链接、方法出口 等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出 栈的过程。 
  >
  > 如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常。
  >
  > 如 果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
  >
  > 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务。

- 本地方法栈 

  > 本地方法栈则为虚 拟机使用到的Native方法服务。

- Java堆

  > 几乎所有的对象实例都在这里分配内存
  >
  > 如 果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异 常。

- 方法区 

  > 存储已被虚 拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。


*运行时常量池* （方法区的一部分）

> Class文件中除了有类的版 本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于 存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常 量池中存放。 

*直接内存* （堆外内存）

> 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓 冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储 在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著 提高性能，因为避免了在Java堆和Native堆中来回复制数据。 



## 内存回收

### 哪些内存需要回收？什么时候回收？

- Java堆和方法区的。

- 废弃常量和无用的类。

- **死去的对象**。

  > 判断对象是否死去：
  >
  > 1、引用计数算法，并没有用
  >
  > 2、可达性分析算法 。在Java语言中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。

### 如何回收？ 

#### 标记-清除算法 

> 算法分 为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有 被标记的对象。
>
> 它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是 空间问题，标记清除之后会产生大量不连续的内存碎片

#### 复制算法 

> 它将可用内存按容 量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
>
> 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生 代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存 分为**一块较大的Eden空间和两块较小的Survivor空间**
>
> 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。

#### 标记-整理算法 

> 根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程 仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存 活的对象都向一端移动，然后直接清理掉端边界以外的内存

#### 分代收集算法 

> 当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算 法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆 分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
>
> 在新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。
>
> 而老年代中因为对象存活率高、没有额外空间 对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

### HotSpot的垃圾收集器

Serial收集器

ParNew收集器 

Parallel Scavenge收集器 

Serial Old收集器 

Parallel Old收集器 

CMS收集器 ：

> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集 器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重 视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常 符合这类应用的需求。 

G1收集器 ：



### 什么是Stop The World？

参照HotSpot的算法实现 ：

从可达性分析中从GC Roots节点找引用链这个操作为例，现 在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时 间。 

另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一 个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看 起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情 况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有 Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因。

什么是**安全点**？OopMap的作用是为了在GC的时候，快速进行可达性分析，所以OopMap并不需要一发生改变就去更新这个映射表。只要这个更新在GC发生之前就可以了。所以OopMap只需要在预先选定的一些位置上记录变化的OopMap就行了。这些特定的点就是SafePoint（安全点）。由此也可以知道，程序并不是在所有的位置上都可以进行GC的，只有在达到这样的安全点才能暂停下来进行GC。

什么是**安全区域**？安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方 开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当 在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离 开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完 成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为 止。 

# 实践--虚拟机内存管理

理论总是作为指导实践的工具，能把这些知识应用到实际工作中才是我们的最终目的。

jps：虚拟机进程状况工具

jstat：虚拟机统计信息监视工具

jinfo：Java配置信息工具

jmap：Java内存映像工具

jhat：虚拟机堆转储快照分析工具

jstack：Java堆栈跟踪工具

HSDIS：JIT生成代码反汇编

JDK的可视化工具

 JConsole：Java监视与管理控制台 

VisualVM：多合一故障处理工具



