# java的锁

java并发一直是面试考察的要点，搜索引擎上到处能看到大家随意复制粘贴概念，垃圾信息太多。

同学们有必要自己冷静整理下。

我试图通过本文把java里面的锁讲清楚。

## 相关的名词和逻辑链整理

### 思考1：什么是线程安全？

Brian Goetz对线程安全的描述：当**多线程访问一个对象**时，如果不用考虑这些线程在运行时环境下的调度和交替，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。

这里的正确的结果是指：对象的实际行为结果符合逻辑上的因果演绎。

如何实现线程安全？

编写线程安全的代码，核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。对象的状态是指存储在状态变量（实例或静态域）中的数据。对象的状态还可能包括其他依赖对象的域。（Map.Entry）

要使得对象是线程安全的，可以采用**同步机制**来协同对对象可变状态的访问。

同步又有两种：

1. 互斥同步

   synchronized

   java.util.concurrent ReentrantLock

2. 非阻塞同步

   CAS，基于冲突检测的 乐观并发策略，基于硬件指令集

要保证线程安全，并不是一定就要进行同步，两者没有因果关系。一些代码天生就是线程安全的，如可重入代码（Reentrant Code），线程本地存储（Thread Local Storage）。

小结：整理一下我们知道，java的锁是同步机制的一种，同步机制是用来协同对对象可变状态的访问，从而使得对象具有线程安全性。

### 思考2：原子性，可见性，有序性

另外，说起java的并发，大家平时经常提到的原子性，可见性，有序性又是什么，大家说这三个性质的时候又是在讨论什么呢？这三个性的出处是哪？

《java编程思想》中提到这三个概念，指的是程序里面的三种毛病（多任务程序）：

例如原子性，JVM可以将long和double变量的读取写入当做是两个32位变量来操作，万一执行到一半的时候任务切换了。。。并且提到volatile关键字可以使其做到原子性。

《深入理解java虚拟机》对这三个性也有描述12.3.5：Java内存模型是围绕着并发过程中如何处理原子性、可见性、有序性这三个特征来建立的。

现在又引出了Java内存模型这个概念。

### Java内存模型

此节大量引用《深入理解java虚拟机》。

Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 

定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）**来获取更好的执行速度**。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的 变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数。

Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措 施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

整理思路。

1、万恶之源是JVM内存模型为了获取更好的执行速度，意味着要利用硬件的多CPU并发、高速缓存、处理器乱序执行优化，编译指令重排序优化这些提高性能的手段。

2、没有银弹，追求这些高性能就要吸收相应的问题，破坏了顺序一致。也就是原子性，可见性，有序性的问题。

3、JVM内存模型通过一些手段实现这3个特性。

**原子性（Atomicity）**：由Java内存模型来直接保证的原子性变量操作包括read、load、 assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例 外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些 几乎不会发生的例外情况）。 如果应用场景需要一个更大范围的原子性保证（经常会遇到），Java内存模型还提供了 lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用， 但是却提供了**更高层次的字节码指令monitorenter和monitorexit**来隐式地使用这两个操作，这 两个字节码指令反映到Java代码中就是同步块——**synchronized**关键字，因此在synchronized块 之间的操作也具备原子性。 

**可见性（Visibility）**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即 得知这个修改。上文在讲解**volatile**变量的时候我们已详细讨论过这一点。Java内存模型是通 过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作 为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与 volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前 立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则 不能保证这一点。 除了volatile之外，Java还有两个关键字能实现可见性，即**synchronized和final**。同步块的 可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、 write操作）”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一 旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事 情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看 见final字段的值。

**有序性（Ordering）**：Java内存模型的有序性在前面讲解volatile时也详细地讨论过 了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有 序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表 现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象 和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻 只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同 步块只能串行地进入。 

现在我们清楚了，线程安全性是对象或者代码的性质，是程序员需要注意的，我们可以通过使用同步机制使对象或者代码具有线程安全性。

原子性，可见性，有序性是JVM内存模型设计上要考虑的问题，目的是使得java程序性能又好，又能对java的使用者提供原子性，可见性，有序性保证，让java用起来溜溜的。

> 注意：我们知道java规范分为java语言规范和java虚拟机规范。synchronized，volatile是java语言里面的概念。而java虚拟机内存模型方面提供了原子性，可见性，有序性保证，具体手段如字节码指令monitorenter，monitorexit，主内存变量刷新等。

说到这里，不妨再了解下jvm的同步指令呢

## jvm的同步指令

貌似只有monitorenter和monitorexit两条指令。。



> 思考题：
>
> java里面有哪些锁？java的锁是怎么实现的？
>
> - Java的内置锁，synchronized块（元老级，Java SE1.6对Synchronized进行了各种优化）
> - JDK提供的显式的Lock对象（Java 5之后，在java.util.concurrent.locks包提供）

## synchronized块

众所周知，synchronized只是一个关键字，使用在同步代码块或方法上。

> synchronized使用发生了什么，它的原理是什么样的?

synchronized块是java提供的强制原子性的内置锁机制。

JavaConcurrencyinPractice告诉我们，一个synchronized块有两部分：锁对象的引用，以及这个锁保护的代码块。

> synchronized块的锁的原理是啥？

java编程思想告诉我们，所有对象都自动含有单一的锁（也称为监视器，监视器锁）。当在对象上调用其任意synchronized的时候。此对象都被加锁，这时该对象上其它的synchronized方法只有等到前面一个方法调用完毕并释放了锁之后才能被调用。

synchronized还是可重入的，JVM负责跟踪对象被加锁的次数。



## 显式的Lock对象

































参考资料：

JavaConcurrencyinPractice

深入理解Java虚拟机

[Java并发编程 Synchronized及其实现原理](https://www.cnblogs.com/mingyao123/p/7424911.html)

[JAVA锁的膨胀过程和优化](https://www.cnblogs.com/dsj2016/p/5714921.html)

[Java并发编程：Lock](https://www.cnblogs.com/dolphin0520/p/3923167.html)