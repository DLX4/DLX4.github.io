# 一个问题带你讲解map

现在有一个问题，小明想做一个函数：把0x1映射到0 ，0x2 映射到1， 0x4映射到2。。。

怎样实现是最优的呢？

## 第一时间想到的方法while

问题等价于把输入数值二进制表示后，它的尾巴有几个0。以64（十进制）为例，二进制是1000000，写一个循环每次右移一位，退出条件是值右移后为0。在循环体里加计数变量每次循环++。

加入一个数尾巴有64个0，循环就要64次。

有没有更好的方法呢？

## 查表

有的同事想出来搞一个map表，事先存储好映射关系：

key   value

0x1-->到0

0x2-->到1

.....

那么我们分析查表这个复杂度是多少？假如我要找100000...0（二进制尾巴64个0），最差情况下，这个数藏在表格最底下，而这个表前面有100个数，我们就要查找比较100次。

当然我们可以按照大小顺序存储，从小到大，0x1 0x2 0x4.。。。这样我们就能二分查找，比较复杂度降到了logN。

这就是顺序表。

我们知道还有一种表叫偏移跳转表：不仅递增，而且行间偏移都一样的。如下：

key   value

0x1-->到0

0x2-->到1

0x3-->null

0x4-->到2

....

这种表的查找过程：加入给我一个key是64（二进制1000000），我直接一步寻址到talble[63]就得到了。这个复杂度就O(1)。但是这种表不适合我们的问题，输入的数可能是（二进制尾巴64个0），空间就很浪费了。

目前看来最棒的方法就是顺序存储复杂度logN了。

还有没有更棒的方法，众所周知C语言实现一个map还是很麻烦的。

## switch case

众所周知，GCC编译器会对switch case进行优化，原理就是根据case条件自动生成了跳转表，原理接近上述的偏移跳转表。

> 思考题：我们问题里面的key分布这么稀疏，GCC会帮我们优化成跳转表吗？

## 难道不能做到O（1）了吗？

答案显然是可以的。参考主流的hashmap的实现。

前面分析知道，顺序跳转表的缺陷是浪费空间，我们的key是2的冥指数很稀疏的。

解决这个问题可以用hash函数，把稀疏的不同的key哈希，使得hash（key）得到的数分布紧密就好了。

hash函数怎么写？我们想到CRC8可以把输入的二进制数打乱输出一个8位的二进制数，比较符合我们的要求。

key   value  hash（key）

0x1-->到0 ；111  

0x2-->到1；1110

0x4-->到2；11100

0x8-->到3；111000

...

0x40-->8 ;    11000111

hash之后的效果就是输入的key被打散了并且都是8位的二进制数。

假如我们的key的取值空间是0x1 0x2  。。。。 100000...0（二进制尾巴63个0），总共64个数。

我们只需要分配64个空间的数组，每个key现在要怎么存到这64个空间里面呢？以0x2为例：

0x2-->hash（0x2）=1110-->  (64 - 1) & hash  就是 数组中的偏移-->table[14]

我们在table[14]上存着0x2-->到1对应的value，也就是1.



这样，获取的时候就是O1了，get（0x2）--> hash（0x2）=1110-->  (64 - 1) & hash  就是 数组中的偏移-->table[14] 从table[14]中取就好了。

hash碰撞的问题这里先不讨论。

